<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Westwind027的个人学习博客]]></title>
  <link href="http://westwind027.ml/atom.xml" rel="self"/>
  <link href="http://westwind027.ml/"/>
  <updated>2016-01-24T15:20:07+08:00</updated>
  <id>http://westwind027.ml/</id>
  <author>
    <name><![CDATA[westwind027]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[OpenResty学习-Lua部分]]></title>
    <link href="http://westwind027.ml/blog/2016/01/24/12/"/>
    <updated>2016-01-24T10:14:01+08:00</updated>
    <id>http://westwind027.ml/blog/2016/01/24/12</id>
    <content type="html"><![CDATA[<ol>
<li><p>数据类型：数值型，字符串型，函数型，表型，用户自定义型（OpenResty编程可能暂时没用到）</p></li>
<li><p>表：统一了数组、散列表。 通过元表实现了面向对象的功能。</p></li>
<li><p>函数：第一类对象。（可以赋值给表量、作为参数传递、以及作为返回值接收）</p></li>
<li><p>全动态函数调用：
 1）调用的函数未知
 2）函数的参数类型和数目也未知</p></li>
</ol>


<blockquote></blockquote>

<pre><code>local function doAction(method, ...)
   local args = {...} or {}
   method(unpack(args, 1, table.maxn(args)))
end
</code></pre>

<ol>
<li>元表：表现行为类似于C++语言中的操作符重载</li>
</ol>


<blockquote></blockquote>

<pre><code>setmetatable(table,metatable):此方法用于为一个表设置元表。
getmetatable(table)：此方法用于获取表的元表对象

——index     在表中查找键不存在时转而在元表中查找该键的功能
__call      使得表能调用
__tostring  实现自定义的字符串装换
__metatable 保护元表
</code></pre>

<ol>
<li>面向对象：数据放表，方法放元表。使用语法糖调用方法</li>
</ol>


<blockquote></blockquote>

<pre><code>obj:x()等价于obj.x(obj)
</code></pre>

<ol>
<li><p>继承：扩展数据部分和方法，放在表里</p></li>
<li><p>成员私有性：通过工厂方法对外提供的闭包来暴露对外接口</p></li>
</ol>


<blockquote><p>注意事项：</p></blockquote>

<ul>
<li><p><code>不要在 lua 的 table 中使用 nil 值，如果一个元素要删除，直接 remove，不要用 nil 去代替</code></p></li>
<li><p><code>不要使用#操作符来计算包含nil的数组长度</code></p></li>
<li><p><code>抵制使用module()函数来定义Lua模块，使用定义对象的方式来组织模块</code></p></li>
</ul>


<blockquote><p>建议：</p></blockquote>

<ul>
<li><p><code>时间：使用ngx_lua模块提供的带缓存的时间接口，如NGX.TODAY, NGX.TIME, NGX.UTCTIME, NGX.LOCALTIME, NGX.NOW, NGX.HTTP_TIME， 以及 NGX.COOKIE_TIME</code></p></li>
<li><p><code>正则：使用ngx.re中的正则表达式，可以通过参数缓存编译过后的Pattern,且实现的是标准的 POSIX 规范</code></p></li>
<li><p><code>函数：建议将函数的定义都放置在自己的Lua module中，再在content_by_lua_file指向的.lua文件中调用它</code></p></li>
<li><p><code>表的非空判断：</code></p></li>
</ul>


<blockquote></blockquote>

<pre><code>function isTableEmpty(t)
    if t == nil or _G.next(t) == nil then
        return true
    else
        return false
    end
end
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go Tour习题实作-循环和函数]]></title>
    <link href="http://westwind027.ml/blog/2016/01/18/11/"/>
    <updated>2016-01-18T20:06:42+08:00</updated>
    <id>http://westwind027.ml/blog/2016/01/18/11</id>
    <content type="html"><![CDATA[<pre><code>package main

import (
    "fmt"
    "math"
)

func Sqrt(x float64) float64 {
    v:=1.0
    r:=10
    for i:=0;i&lt;r;i++{
        v=v-(v*v-x)/(2*v)
    }
    return v
}

func main() {
    fmt.Println(Sqrt(2))
    fmt.Println(math.Sqrt(2))
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go Tour习题实作-slice]]></title>
    <link href="http://westwind027.ml/blog/2016/01/18/10/"/>
    <updated>2016-01-18T19:41:24+08:00</updated>
    <id>http://westwind027.ml/blog/2016/01/18/10</id>
    <content type="html"><![CDATA[<pre><code>package main

import "golang.org/x/tour/pic"

func Pic(dx, dy int) [][]uint8 {
    v:=make([][]uint8,dy)
    for i:= range v{
        v[i] = make([]uint8,dx)
        for j:= range v[i]{
            v[i][j] = uint8((i^j)/2)
        }
    }
    return v
}

func main() {
    pic.Show(Pic)
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go Tour习题实作-map]]></title>
    <link href="http://westwind027.ml/blog/2016/01/18/9/"/>
    <updated>2016-01-18T19:41:18+08:00</updated>
    <id>http://westwind027.ml/blog/2016/01/18/9</id>
    <content type="html"><![CDATA[<pre><code>package main

import (
    "golang.org/x/tour/wc"
    "strings"
)

func WordCount(s string) map[string]int {
    r:=make(map[string]int)
    for _,v:=range strings.Fields(s){
        r[v]+=1
    }
    return r
}

func main() {
    wc.Test(WordCount)
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go Tour习题实作-斐波纳契闭包]]></title>
    <link href="http://westwind027.ml/blog/2016/01/18/8/"/>
    <updated>2016-01-18T19:41:16+08:00</updated>
    <id>http://westwind027.ml/blog/2016/01/18/8</id>
    <content type="html"><![CDATA[<pre><code>package main

import "fmt"

// fibonacci 函数会返回一个返回 int 的函数。
func fibonacci() func() int {
    f1:=1
    f2:=0
    return func() int{
        f1,f2 =f2,f1+f2
        return f1
    }
}

func main() {
    f := fibonacci()
    for i := 0; i &lt; 10; i++ {
        fmt.Println(f())
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go Tour习题实作-Stringers]]></title>
    <link href="http://westwind027.ml/blog/2016/01/18/7/"/>
    <updated>2016-01-18T19:41:13+08:00</updated>
    <id>http://westwind027.ml/blog/2016/01/18/7</id>
    <content type="html"><![CDATA[<pre><code>package main

import "fmt"

type IPAddr [4]byte

// TODO: Add a "String() string" method to IPAddr.
func (p *IPAddr) String() string{
    return fmt.Sprintf("%v.%v.%v.%v",p[0],p[1],p[2],p[3])
}

func main() {
    addrs := map[string]IPAddr{
        "loopback":  {127, 0, 0, 1},
        "googleDNS": {8, 8, 8, 8},
    }
    for n, a := range addrs {
        fmt.Printf("%v: %v\n", n, &amp;a)
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go Tour习题实作-错误]]></title>
    <link href="http://westwind027.ml/blog/2016/01/18/6/"/>
    <updated>2016-01-18T19:41:09+08:00</updated>
    <id>http://westwind027.ml/blog/2016/01/18/6</id>
    <content type="html"><![CDATA[<pre><code>package main

import (
    "fmt"
)

type ErrNegativeSqrt float64

func (e ErrNegativeSqrt) Error() string{
    return fmt.Sprintf("%v:%v","Cannot Sqrt negative number",float64(e))
}

func err(x float64) error{
    if x&gt;0 {return nil}
    return ErrNegativeSqrt(x)
}

func Sqrt(x float64) (float64, error) {
    if x&lt;0 {
        return x,err(x)
    }

    v:=1.0
    r:=10
    for i:=0;i&lt;r;i++{
        v=v-(v*v-x)/(2*v)
    }
    return v,err(x)

}



func main() {
    fmt.Println(Sqrt(2))
    fmt.Println(Sqrt(-2))
}
</code></pre>

<blockquote><p>注意类型转换，避免出现死循环</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go Tour习题实作-A Reader]]></title>
    <link href="http://westwind027.ml/blog/2016/01/17/5/"/>
    <updated>2016-01-17T18:13:35+08:00</updated>
    <id>http://westwind027.ml/blog/2016/01/17/5</id>
    <content type="html"><![CDATA[<pre><code>package main

import "golang.org/x/tour/reader"

type MyReader struct{
}

// TODO: Add a Read([]byte) (int, error) method to MyReader.
func (p MyReader) Read(c []byte) (int, error){
    c[0]='A'
    return 1,nil
}

func main() {
    reader.Validate(MyReader{})
}
</code></pre>

<blockquote><p>Read使用的参数是关键</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go Tour习题实作-ROT13]]></title>
    <link href="http://westwind027.ml/blog/2016/01/17/4/"/>
    <updated>2016-01-17T18:13:31+08:00</updated>
    <id>http://westwind027.ml/blog/2016/01/17/4</id>
    <content type="html"><![CDATA[<pre><code>package main

import (
    "io"
    "os"
    "strings"
)

type rot13Reader struct {
    r io.Reader
}

func (p *rot13Reader)Read(c []byte)(i int,e error){

    i,e = p.r.Read(c)
    for i:=range c {
        switch {
        case c[i]&lt;'N':c[i]+=13
        case c[i]&lt;'a':c[i]-=13
        case c[i]&lt;'n':c[i]+=13
        case c[i]&lt;='z':c[i]-=13
        default:
        }
    }
    return i,e
}



func main() {
    s := strings.NewReader("Lbh penpxrq gur pbqr!")
    r := rot13Reader{s}
    io.Copy(os.Stdout, &amp;r)
}
</code></pre>

<blockquote><p>注意区分大小写就行，写完发现Read定义很容易扩展</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go Tour习题实作-HTTP处理]]></title>
    <link href="http://westwind027.ml/blog/2016/01/17/3/"/>
    <updated>2016-01-17T18:13:30+08:00</updated>
    <id>http://westwind027.ml/blog/2016/01/17/3</id>
    <content type="html"><![CDATA[<pre><code>package main

import (
    "log"
    "fmt"
    "net/http"
)

type String string

type Struct struct {
    Greeting string
    Punct    string
    Who      string
}

func (p String)ServeHTTP(w http.ResponseWriter,
                          r *http.Request){
    fmt.Fprint(w, p)
}

func (p *Struct)ServeHTTP(w http.ResponseWriter,
                          r *http.Request){
    fmt.Fprint(w, p.Greeting,p.Punct,p.Who)
}

func main() {
    http.Handle("/string", String("I'm a frayed knot."))
    http.Handle("/struct", &amp;Struct{"Hello", ":", "Gophers!"})
    log.Fatal(http.ListenAndServe("localhost:4001", nil))
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go Tour习题实作-图片]]></title>
    <link href="http://westwind027.ml/blog/2016/01/17/2/"/>
    <updated>2016-01-17T18:13:27+08:00</updated>
    <id>http://westwind027.ml/blog/2016/01/17/2</id>
    <content type="html"><![CDATA[<pre><code>package main

import( 
    "golang.org/x/tour/pic"
    "image"
    "image/color"
)

type Image struct{}

func (p Image)ColorModel() color.Model{
    return color.RGBAModel
}

func (p Image)At(x, y int) color.Color{
    v :=uint8(x^y)
    return color.RGBA{v,v, 255, 255}
}

func (p Image)Bounds() image.Rectangle{
    w:=800
    h:=400
    return image.Rect(0, 0, w, h)
}


func main() {
    m := Image{}
    pic.ShowImage(m)
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go Tour习题实作-二叉数遍历]]></title>
    <link href="http://westwind027.ml/blog/2016/01/17/1/"/>
    <updated>2016-01-17T18:13:22+08:00</updated>
    <id>http://westwind027.ml/blog/2016/01/17/1</id>
    <content type="html"><![CDATA[<pre><code>package main

import(
    "golang.org/x/tour/tree"
    "fmt"
)
// Walk 步进 tree t 将所有的值从 tree 发送到 channel ch。
func Walk(t *tree.Tree, ch chan int){
    switch t.Left{
        case nil: 
        default: 
            Walk(t.Left,ch)
    }

    ch&lt;-t.Value

    switch t.Right{
        case nil: 
        default: 
            Walk(t.Right,ch)
    }

}

// Same 检测树 t1 和 t2 是否含有相同的值。
func Same(t1, t2 *tree.Tree) bool {
    ch1 := make(chan int,10)
    ch2 := make(chan int,10)
    go Walk(t1,ch1)
    go Walk(t2,ch2)
    for i:=0;i&lt;10;i++{
        if &lt;-ch1!=&lt;-ch2 {
            return false
        }
    }
    return true
}

func main() {
    fmt.Println("first is ",Same(tree.New(1), tree.New(1)))
    fmt.Println("second is ",Same(tree.New(1), tree.New(2)))
}
</code></pre>

<blockquote><p>主要是遍历的实现，这里的写法比较麻烦一点</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go Tour习题实作-爬虫]]></title>
    <link href="http://westwind027.ml/blog/2016/01/17/0/"/>
    <updated>2016-01-17T17:02:34+08:00</updated>
    <id>http://westwind027.ml/blog/2016/01/17/0</id>
    <content type="html"><![CDATA[<pre><code>package main

import (
    "fmt"
    "sync"
)


var quit chan int = make(chan int)
var p *Mymap= &amp;Mymap{m: make(map[string]bool)}
type Mymap struct{
    m map[string]bool
    ins int
    mux sync.Mutex
}

func (p *Mymap)Check(s string)bool{
    p.mux.Lock()
    defer p.mux.Unlock()

    if p.m[s]{
        return false
    }else{
        p.m[s]=true
        p.ins+=1
        fmt.Printf("Check_ins: %v\n", p.ins)
        return true
    }
}

func (p *Mymap)Dec(){
    p.mux.Lock()
    defer p.mux.Unlock()
    p.ins-=1
    fmt.Printf("Dec_ins: %v\n", p.ins)
}

func (p *Mymap)Quit()bool{
    p.mux.Lock()
    defer p.mux.Unlock()
    //fmt.Printf("ins: %v\n", p.ins)
    if p.ins==0 {
        return true
    }else{
        return false
    }
}

type Fetcher interface {
    // Fetch 返回 URL 的 body 内容，并且将在这个页面上找到的 URL 放到一个 slice 中。
    Fetch(url string) (body string, urls []string, err error)
}

// Crawl 使用 fetcher 从某个 URL 开始递归的爬取页面，直到达到最大深度。
func Crawl(url string, depth int, fetcher Fetcher) {
    // TODO: 并行的抓取 URL。
    // TODO: 不重复抓取页面。

  if depth &lt;= 0 {
    p.Dec()
    return
  }
  if p.Check(url){
    go func(){
      body, urls, err := fetcher.Fetch(url)
      if err != nil {
        fmt.Println(err)
        p.Dec()
        if p.Quit() {
          quit&lt;-0
        }
        return
      }else{
        fmt.Printf("found: %s %q\n", url, body)
        for _, u := range urls {
          Crawl(u, depth-1, fetcher)
        }

        p.Dec()
        if p.Quit() {
          quit&lt;-0
        }
      } 
    }()
  }
  return
}

func main() {
  Crawl("http://golang.org/", 4, fetcher)
  &lt;-quit
}

// fakeFetcher 是返回若干结果的 Fetcher。
type fakeFetcher map[string]*fakeResult

type fakeResult struct {
    body string
    urls []string
}

func (f fakeFetcher) Fetch(url string) (string, []string, error) {
    if res, ok := f[url]; ok {
        return res.body, res.urls, nil
    }
    return "", nil, fmt.Errorf("not found: %s", url)
}

// fetcher 是填充后的 fakeFetcher。
var fetcher = fakeFetcher{
    "http://golang.org/": &amp;fakeResult{
        "The Go Programming Language",
        []string{
            "http://golang.org/pkg/",
            "http://golang.org/cmd/",
        },
    },
    "http://golang.org/pkg/": &amp;fakeResult{
        "Packages",
        []string{
            "http://golang.org/",
            "http://golang.org/cmd/",
            "http://golang.org/pkg/fmt/",
            "http://golang.org/pkg/os/",
        },
    },
    "http://golang.org/pkg/fmt/": &amp;fakeResult{
        "Package fmt",
        []string{
            "http://golang.org/",
            "http://golang.org/pkg/",
        },
    },
    "http://golang.org/pkg/os/": &amp;fakeResult{
        "Package os",
        []string{
            "http://golang.org/",
            "http://golang.org/pkg/",
        },
    },
}
</code></pre>

<blockquote><p>本节主要难点在并发位置的选取和如何等待所有任务完成</p>

<p>避免重复这里使用了一个MAP来完成</p></blockquote>
]]></content>
  </entry>
  
</feed>
